package induction.problem.event3;

import java.util.ArrayList;
import java.util.HashMap;

/**
 *
 * @author konstas
 */
public class MRToken
{
    private Event3Model model;
    private int event;
    private HashMap<Integer, ArrayList<Integer>> fields;

    /**
     * Constructor used for Gold-standard MRs
     * @param event
     */
    public MRToken(int event)
    {
        this.event = event;
        this.fields = new HashMap<Integer, ArrayList<Integer>>();
    }

    /**
     * Constructor used for MRs generated by the model
     * @param model reference to the Event3Model.
     * Used only in order to extract none_f for each event, via fieldsMap
     * @param event
     */   
    public MRToken(Event3Model model, int event)
    {
        this(event);
        this.model = model;
    }
   
    private void addField(int fieldId)
    {
        if(!fields.containsKey(fieldId))
            fields.put(fieldId, new ArrayList<Integer>());
    }

    private void addValue(int fieldId, int value)
    {
        fields.get(fieldId).add(value);
    }

    public void parseMrToken(int curEvent, int curField, int curValue)
    {
//        if(curField < ex.events[curEvent].F)
        if(curField < model.getFieldsMap().get(curEvent).get("none_f"))
        {
            addField(curField);
            if(curValue > -1)
            {
                addValue(curField, curValue);
            }
        }
    }

    public void parseMrToken(int curField, int curValue)
    {
        addField(curField);
        addValue(curField, curValue);
    }

    @Override
    public boolean equals(Object obj)
    {
        assert obj instanceof MRToken;
        MRToken mr = (MRToken)obj;
        if(this.event != mr.event)
            return false;
        for(Integer fieldId : this.fields.keySet())
        {
            if(!mr.fields.containsKey(fieldId))
                return false;
            // normally not a list
            ArrayList<Integer> thisValues = fields.get(fieldId);
            ArrayList<Integer> mrValues = mr.fields.get(fieldId);
            // change that, very naive
            if(thisValues.size() != mrValues.size())
                return false;
            for(Integer value : thisValues)
            {
                if(!mrValues.contains(value))
                {
                    return false;
                }
            }
        }
        return true;
    }

    @Override
    public int hashCode()
    {
        int hash = 3;
        hash = 79 * hash + this.event;
        hash = 79 * hash + (this.fields != null ? this.fields.hashCode() : 0);
        return hash;
    }
}
