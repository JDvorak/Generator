package induction.problem.dmv.generative;

import edu.uci.ics.jung.graph.Graph;
import fig.basic.Indexer;
import fig.basic.LogInfo;
import fig.basic.StopWatchSet;
import induction.DepTree;
import induction.Hypergraph;
import induction.Hypergraph.HyperedgeInfo;
import induction.Hypergraph.HyperpathResult;
import induction.problem.AHypergraphInferState;
import induction.problem.AModel;
import induction.problem.AWidget;
import induction.problem.InferSpec;
import static induction.problem.dmv.Constants.*;
import induction.problem.dmv.params.DMVParams;
import induction.problem.wordproblem.WordModel;

/**
 *
 * @author konstas
 */
public class DMVInferState extends AHypergraphInferState<DepTree, DMVExample, DMVParams>
{
    protected Graph graph;
    protected boolean useHarmonicWeights;
    protected int[] words;
    protected int N;
    protected double tol = 1e-10;
    protected int[][] wordIndexer;
    protected Indexer<String> vocabulary;
    protected final static int Z0 = 0, // Needs to be generated by someone in this span
                               Z1 = 1, // Already generated by someone outside the span
                               Z1m = 2, // Already generated by someone outside the span, needs to generate someone in this span
                               Z = 3;
    
    public DMVInferState(AModel model, DMVExample ex, DMVParams params,
                                 DMVParams counts, InferSpec ispec, boolean useHarmonicWeights)
    {
        super(model, ex, params, counts, ispec);
        this.useHarmonicWeights = useHarmonicWeights;
    }
    
    public DMVInferState(AModel model, DMVExample ex, DMVParams params,
                                 DMVParams counts, InferSpec ispec, boolean useHarmonicWeights, Graph graph)
    {
        this(model, ex, params, counts, ispec, useHarmonicWeights);
        this.graph = graph;
    }
     
    @Override
    protected void initInferState(AModel model)
    {
        words = ex.getText();
        N = ex.N();
        this.vocabulary = ((WordModel)model).getWordIndexer();
    }
    
    @Override
    protected AWidget newWidget()
    {
        return new DepTree(N);
    }   
    
    @Override
    protected void createHypergraph(Hypergraph<DepTree> hypergraph)
    {
        hypergraph.setup(this, opts.debug, opts.modelType, true, -1, null, -1, 
                         opts.reorderType, false, opts.oracleReranker, false,
                         -1, 
                         -1, false, 
                         vocabulary, null, graph);       
        // allowEmptyNodes = true we need this because not all nodes have parent/children
        Indexer<Integer>[] indexer = ((GenerativeDMVModel)model).getLocalWordIndexer();
        wordIndexer = new int[N][N];        
        for(int i = 0; i < N; i++)
            for(int j = 0; j < N; j++)
                wordIndexer[i][j] = indexer[words[i]].indexOf(words[j]);
        
        // By default, assume we're going to stop on adjacent (i.e., generate no children)
        // Later, if we decide to generate children, we're going to divide out the potential for stopping
        // NOTE: if the probability of stopping on adjacent is 0, then we ignore it
        if (!useHarmonicWeights) 
        {
            String defaultNode = "default";
            hypergraph.addProdNode(defaultNode);
            hypergraph.addEdge(hypergraph.prodStartNode(), defaultNode);
            for(int i = 0; i < N; i++)
            {
                final int iIter = i;
                if (!trueInfer || ex.getTrueWidget().getParent()[i] == i)
                {
                    hypergraph.addEdge(defaultNode, new Hypergraph.HyperedgeInfo<DepTree>() {
                        double leftCont = get(params.continues[words[iIter]][R_LEFT0], F_STOP );
                        double rightCont = get(params.continues[words[iIter]][R_RIGHT0], F_STOP );                        
                        @Override
                        public double getWeight()
                        {
//                            return 1.0;
                            return (leftCont > tol ? leftCont : 1.0) *
                                   (rightCont > tol ? rightCont : 1.0);
                        }
                        @Override
                        public void setPosterior(double prob)
                        {
//                            LogInfo.dbg("DEFAULT: SET " + iIter + " " + prob);
                            if(leftCont > tol) 
                                update(counts.continues[words[iIter]][R_LEFT0], F_STOP, prob);
                            if(rightCont > tol)    
                                update(counts.continues[words[iIter]][R_RIGHT0], F_STOP, prob);
                        }
                        @Override
                        public DepTree choose(DepTree widget){return widget;}
                    });
                } // if
            } // for
        } // if (!useHarmonicWeights)
        
        // Choose the root
        String headNode = "head";
        hypergraph.addSumNode(headNode);
        hypergraph.addEdge(hypergraph.prodStartNode(), headNode);
        for(int i = 0; i  < N; i++)
        {
            final int iIter = i;
            hypergraph.addEdge(headNode, gen(0, iIter, Z0, Z1), gen(iIter, N - 1, Z1, Z0), new Hypergraph.HyperedgeInfo<DepTree>() {

                @Override
                public double getWeight()
                {
                    return get(params.starts, words[iIter]);
                }
                @Override
                public void setPosterior(double prob)
                {
                    update(counts.starts, words[iIter], prob);
                }
                @Override
                public DepTree choose(DepTree widget)
                {
                    widget.getParent()[iIter] = iIter;
                    return widget;
                }
            });
        } // for                
    }
        
    @Override
    public void doInference()
    {
        StopWatchSet.begin("computePosteriors");
//        hypergraph.computePosteriors(ispec.isHardUpdate());
        hypergraph.computePosteriors(false);
        StopWatchSet.end();
        // Hard inference
        if (hardInfer)
        {
            HyperpathResult result = hypergraph.fetchBestHyperpath(newWidget());
//            HyperpathResult<Widget> result = hypergraph.fetchSampleHyperpath(opts.initRandom, newWidget());
            bestWidget = (DepTree)result.widget;
            logVZ = result.logWeight;
//            System.out.println("logVZ = "+logVZ);
        }
        else
        {
            bestWidget = (DepTree)newWidget();
            logVZ = Double.NaN;
        }
        updateStats();
    }

    @Override
    public void updateCounts()
    {
        synchronized(counts)
        {
          if(ispec.isMixParamsCounts())
          {
              counts.saveSum();
          }
          StopWatchSet.begin("fetchPosteriors");
          hypergraph.fetchPosteriors(ispec.isHardUpdate());
          StopWatchSet.end();
        }
    }
    
    protected HyperedgeInfo link(final int i, final int j, final int r) 
    {
        final int d; // Direction      
        if (r == R_LEFT0 || r == R_LEFT1) 
            d = D_LEFT;
        else if(r == R_RIGHT0 || r == R_RIGHT1) 
            d = D_RIGHT;
        else 
        { 
            LogInfo.error("Bad: " + r); 
            d = -1;
        }

        if (r == R_LEFT0 || r == R_RIGHT0) // Adjacent            
        {
            final int rr; // Non-adjacent version     
            if (r == R_LEFT0) 
                rr = R_LEFT1;
            else if (r == R_RIGHT0) 
                rr = R_RIGHT1;
            else 
            { 
                LogInfo.error("Bad: " + r); 
                rr = -1;
            }
            return new HyperedgeInfo<DepTree>() {
                double cont = get(params.continues[words[i]][r], F_STOP);       
                @Override
                public double getWeight()
                {
                    return useHarmonicWeights ? 
                            harmonicWeight(i, j, true) : 
                            get(params.deps[words[i]][d], wordIndexer[i][j]) *
                            get(params.continues[words[i]][r], F_CONT) *
                            get(params.continues[words[i]][rr], F_STOP) /
                            (cont > tol ? cont : 1.0);
                }
                @Override
                public void setPosterior(double prob)
                {
                    update(counts.deps[words[i]][d], wordIndexer[i][j], prob);
                    update(counts.continues[words[i]][r], F_CONT, prob);
                    update(counts.continues[words[i]][rr], F_STOP, prob);
                    if(cont > tol)
                        update(counts.continues[words[i]][r], F_STOP, -prob);
                }
                @Override
                public DepTree choose(DepTree widget)
                {
                    widget.getParent()[j] = i; 
                    return widget;
                }
            };        

        } // if (adjacent)
        else if(r == R_LEFT1 || r == R_RIGHT1) // Non-adjacent
        { 
            return new HyperedgeInfo<DepTree>() {        
                @Override
                public double getWeight()
                {
                    return useHarmonicWeights ? 
                        harmonicWeight(i, j, false) : 
                        get(params.deps[words[i]][d], wordIndexer[i][j]) *
                        get(params.continues[words[i]][r], F_CONT);
                }
                @Override
                public void setPosterior(double prob)
                {
                    //LogInfo.dbg("NON-ADJ: SET " + (i,j,r) + " " + prob);
                    update(counts.deps[words[i]][d], wordIndexer[i][j], prob);
                    update(counts.continues[words[i]][r], F_CONT, prob);
                }
                @Override
                public DepTree choose(DepTree widget)
                {
                    widget.getParent()[j] = i;
                    return widget;
                }                        
            };
        } // else if (non-adjacent)
        else
            throw new RuntimeException("Bad");
    } // link

    /**
     * For each span [i,j] and state of the endpoints, (zi, zj), sum over sub-dependency structures
       Convention: first attach left arguments from j
     * @param i
     * @param j
     * @param zi
     * @param zj
     * @return 
     */
    protected Object gen(final int i, final int j, final int zi, final int zj)
    {
        assert (i <= j);
        if (i == j) 
        { // Base case
          if ((zi == Z1 || zj == Z1) && // i is generated by someone
              (zi != Z1m && zj != Z1m)) // i doesn't need to generate
            return hypergraph.endNode;
          else
            return hypergraph.invalidNode;
        }
        else if (i < j && zi == Z0 && zj == Z0) // No one to generate i and j
          return hypergraph.invalidNode; 
        else 
        {
            Node node = new Node(i, j, zi, zj);
            if (hypergraph.addSumNode(node)) 
            {
                switch(zj) 
                {
                    case Z1 :
                        hypergraph.addEdge(node, gen(i, j-1, zi, Z0)); // No link from j
                        hypergraph.addEdge(node, gen(i, j, zi, Z1m)); // Link (somewhere) from j
                        break;
                    case Z1m :
                        for(int k = zi == Z0 ? i : i + 1; k < j; k++) // i ... k <- j
                        {
                            if (!trueInfer || ex.getTrueWidget().getParent()[k] == j) 
                            {
                                hypergraph.addEdge(node, gen(i, k, zi, Z1), 
                                                         gen(k, j-1, Z1, Z0), 
                                                         link(j, k, R_LEFT0)); // First link
                                hypergraph.addEdge(node, gen(i, k, zi, Z1), 
                                                         gen(k, j, Z1, Z1m), 
                                                         link(j, k, R_LEFT1)); // Not first link
                            }
                        } break;
                    case Z0 :
                        assert (zi != Z0);
                        for(int k = i +1; k < j + 1; k++) // i -> k ... j
                        {
                            if (!trueInfer || ex.getTrueWidget().getParent()[k] == i) 
                            {
                                hypergraph.addEdge(node, gen(i+1, k, Z0, Z1), 
                                                     gen(k, j, Z1, zj), 
                                                     link(i, k, R_RIGHT0)); // First link
                                hypergraph.addEdge(node, gen(i, k, Z1m, Z1), 
                                                     gen(k, j, Z1, zj), 
                                                     link(i, k, R_RIGHT1)); // Not first link
                            }
                        } break;                                                  
                } // switch
            //if (hypergraph.numEdges(node) == 0) fail(node)
            } // if
            return node;
        } // else
    } // gen
    
    private double harmonicWeight(int i, int j, boolean adj)
    {
        return 1.0/(Math.abs(i-j) + 2);// * (adj ? 1.0 : 1.0/(Math.abs(i-j) + 3));
    }
}
